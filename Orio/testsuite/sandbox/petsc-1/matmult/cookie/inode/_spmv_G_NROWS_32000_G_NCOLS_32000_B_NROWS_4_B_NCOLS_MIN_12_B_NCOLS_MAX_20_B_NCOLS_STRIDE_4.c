/*@ begin PerfTuning (  
 def build { 
   arg build_command = 'icc -O3 -openmp -lm -I/disks/fast/papi/include -L/disks/fast/papi/lib -lpapi';
 }

 def performance_counter {
   arg repetitions = 100;
 }

 def performance_params {
   param UNROLL_FAC_OUT[] = [4];
   param UNROLL_FAC_IN[] = [1,2,3,4,5,6,7,8];
   param N_THREADS[] = [1,4];
   param SIMD_TYPE[] = ['none','sse'];
   param BLK_TYPE[] = ['inode'];

   constraint simd_unroll_factor = (SIMD_TYPE=='none' or UNROLL_FAC_IN%2==0);
 }

 def input_params {
   param G_NROWS[] = [32000,34000];
   param G_NCOLS[] = [32000,34000];
   param B_NROWS[] = [4];
   param B_NCOLS_MIN[] = [12];
   param B_NCOLS_MAX[] = [20];
   param B_NCOLS_STRIDE[] = [4];

   constraint square_x_y = (G_NROWS==G_NCOLS);
 }
 
 def input_vars { 
   arg decl_file = 'decl_code.h';
   arg init_file = 'init_code.c'; 
 } 
 
 def performance_test_code { 
   arg skeleton_code_file = 'skeleton_code.c';  
 } 

 def search
 {
   arg algorithm = 'Exhaustive';
 }  
 ) @*/

/**-- (Generated by Orio) 
Best performance cost: 
  412853.000000 
Tuned for specific problem sizes: 
  B_NCOLS_MAX = 20 
  B_NCOLS_MIN = 12 
  B_NCOLS_STRIDE = 4 
  B_NROWS = 4 
  G_NCOLS = 32000 
  G_NROWS = 32000 
Best performance parameters: 
  BLK_TYPE = inode 
  N_THREADS = 4 
  SIMD_TYPE = sse 
  UNROLL_FAC_IN = 8 
  UNROLL_FAC_OUT = 4 
--**/

 

/*@ begin SpMV (
  # SpMV computation: y = y + aa * x;
  out_vector = y;
  in_vector = x;
  in_matrix = aa;
  row_inds = ai;
  col_inds = aj;
  data_type = double;
  init_val = 0;
  total_rows = total_rows;       
  total_inodes = total_inodes;   
  inode_sizes = inode_sizes;     
  inode_rows = inode_rows;       
  
  # transformation parameters
  out_unroll_factor = UNROLL_FAC_OUT;
  in_unroll_factor = UNROLL_FAC_IN;
  num_threads = N_THREADS;
  simd = SIMD_TYPE;              # 'none' (default), 'gcc', 'sse', 'xlc'
  block_structure = BLK_TYPE;    # 'none' (default), 'inode', 'bcsr' (still unsupported)
  ) @*/
{

  double tbuf[8];
  register int n;
  omp_set_num_threads(4);
  #pragma omp parallel for shared(y,x,aa,ai,aj,total_inodes,inode_rows) private(n,tbuf)
  for (n=0; n<=total_inodes-1; n+=1) {
    int start_row=inode_rows[n];
    register int rlength=inode_rows[n+1]-start_row;
    int first_col=ai[start_row];
    register int clength=ai[start_row+1]-first_col;
    double *yc=&y[start_row];
    int *ajc=&aj[first_col];
    double *aac=&aa[first_col];
    register int i=0;
    while (i<=rlength-4) {
      double *aa1c=aac+clength,*aa2c=aa1c+clength,*aa3c=aa2c+clength;
      __m128d y0cv=_mm_set1_pd(0),y1cv=_mm_set1_pd(0),y2cv=_mm_set1_pd(0),y3cv=_mm_set1_pd(0);
      register int j=0;
      while (j<=clength-8) {
        __m128d x0v=_mm_setr_pd(x[ajc[0]],x[ajc[1]]),x1v=_mm_setr_pd(x[ajc[2]],x[ajc[3]]),x2v=_mm_setr_pd(x[ajc[4]],x[ajc[5]]),x3v=_mm_setr_pd(x[ajc[6]],x[ajc[7]]);
        __m128d aacv0=_mm_load_pd(&aac[0]),aacv1=_mm_load_pd(&aac[2]),aacv2=_mm_load_pd(&aac[4]),aacv3=_mm_load_pd(&aac[6]);
        __m128d aa1cv0=_mm_load_pd(&aa1c[0]),aa1cv1=_mm_load_pd(&aa1c[2]),aa1cv2=_mm_load_pd(&aa1c[4]),aa1cv3=_mm_load_pd(&aa1c[6]);
        __m128d aa2cv0=_mm_load_pd(&aa2c[0]),aa2cv1=_mm_load_pd(&aa2c[2]),aa2cv2=_mm_load_pd(&aa2c[4]),aa2cv3=_mm_load_pd(&aa2c[6]);
        __m128d aa3cv0=_mm_load_pd(&aa3c[0]),aa3cv1=_mm_load_pd(&aa3c[2]),aa3cv2=_mm_load_pd(&aa3c[4]),aa3cv3=_mm_load_pd(&aa3c[6]);
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv0,x0v));
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv1,x1v));
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv2,x2v));
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv3,x3v));
        y1cv=_mm_add_pd(y1cv,_mm_mul_pd(aa1cv0,x0v));
        y1cv=_mm_add_pd(y1cv,_mm_mul_pd(aa1cv1,x1v));
        y1cv=_mm_add_pd(y1cv,_mm_mul_pd(aa1cv2,x2v));
        y1cv=_mm_add_pd(y1cv,_mm_mul_pd(aa1cv3,x3v));
        y2cv=_mm_add_pd(y2cv,_mm_mul_pd(aa2cv0,x0v));
        y2cv=_mm_add_pd(y2cv,_mm_mul_pd(aa2cv1,x1v));
        y2cv=_mm_add_pd(y2cv,_mm_mul_pd(aa2cv2,x2v));
        y2cv=_mm_add_pd(y2cv,_mm_mul_pd(aa2cv3,x3v));
        y3cv=_mm_add_pd(y3cv,_mm_mul_pd(aa3cv0,x0v));
        y3cv=_mm_add_pd(y3cv,_mm_mul_pd(aa3cv1,x1v));
        y3cv=_mm_add_pd(y3cv,_mm_mul_pd(aa3cv2,x2v));
        y3cv=_mm_add_pd(y3cv,_mm_mul_pd(aa3cv3,x3v));
        aac+=8; aa1c+=8; aa2c+=8; aa3c+=8;
        ajc+=8;
        j+=8;
      }
      _mm_storer_pd(&tbuf[0],y0cv); _mm_storer_pd(&tbuf[2],y1cv); _mm_storer_pd(&tbuf[4],y2cv); _mm_storer_pd(&tbuf[6],y3cv);
      double y0c=tbuf[0]+tbuf[1],y1c=tbuf[2]+tbuf[3],y2c=tbuf[4]+tbuf[5],y3c=tbuf[6]+tbuf[7];
      while (j<=clength-1) {
        double x0=x[ajc[0]];
        y0c += aac[0]*x0;
        y1c += aa1c[0]*x0;
        y2c += aa2c[0]*x0;
        y3c += aa3c[0]*x0;
        aac+=1; aa1c+=1; aa2c+=1; aa3c+=1;
        ajc+=1;
        j+=1;
      }
      yc[0]=y0c; yc[1]=y1c; yc[2]=y2c; yc[3]=y3c;
      yc+=4;
      aac=aa3c;
      ajc+=3*clength;
      i+=4;
    }
    while (i<=rlength-1) {
      __m128d y0cv=_mm_set1_pd(0);
      register int j=0;
      while (j<=clength-8) {
        __m128d x0v=_mm_setr_pd(x[ajc[0]],x[ajc[1]]),x1v=_mm_setr_pd(x[ajc[2]],x[ajc[3]]),x2v=_mm_setr_pd(x[ajc[4]],x[ajc[5]]),x3v=_mm_setr_pd(x[ajc[6]],x[ajc[7]]);
        __m128d aacv0=_mm_load_pd(&aac[0]),aacv1=_mm_load_pd(&aac[2]),aacv2=_mm_load_pd(&aac[4]),aacv3=_mm_load_pd(&aac[6]);
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv0,x0v));
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv1,x1v));
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv2,x2v));
        y0cv=_mm_add_pd(y0cv,_mm_mul_pd(aacv3,x3v));
        aac+=8;
        ajc+=8;
        j+=8;
      }
      _mm_storer_pd(&tbuf[0],y0cv);
      double y0c=tbuf[0]+tbuf[1];
      while (j<=clength-1) {
        y0c += aac[0]*x[ajc[0]];
        aac+=1;
        ajc+=1;
        j+=1;
      }
      yc[0]=y0c;
      yc+=1;
      i+=1;
    }
  }
  
}
/*@ end @*/

/*@ end @*/

