
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <math.h>

#define tmax T
#define nx N
#define ny N
double ex[nx][ny +1];
double ey[nx +1][ny];
double hz[nx][ny];

void init_arrays()
{
    int i, j;
    for (i=0; i<nx+1; i++)  {
        for (j=0; j<ny; j++)  {
            ey[i][j] = 0;
        }
    }
    for (i=0; i<nx; i++)  {
        for (j=0; j<ny+1; j++)  {
            ex[i][j] = 0;
        }
    }
    for (j=0; j<ny; j++)  {
        ey[0][j] = ((double)j)/ny;
    }
    for (i=0; i<nx; i++)    {
        for (j=0; j<ny; j++)  {
            hz[i][j] = 0;
        }
    }
}

double rtclock()
{
  struct timezone tzp;
  struct timeval tp;
  int stat;
  gettimeofday (&tp, &tzp);
  return (tp.tv_sec + tp.tv_usec*1.0e-6);
}

int main()
{
  init_arrays();

  double annot_t_start=0, annot_t_end=0, annot_t_total=0;
  int annot_i;

  for (annot_i=0; annot_i<REPS; annot_i++)
  {
    annot_t_start = rtclock();
    
/*@ begin PerfTuning (
  def build
  {
    arg build_command = 'icc -O3 -openmp -lm';
  }

  def performance_counter
  {
    arg repetitions = 10;
  }
  
  def performance_params
  {
    param U1[] = [14];
    param U2i[] = [1];
    param U2j[] = [1];
    param U3i[] = [6];
    param U3j[] = [1];
    param U4i[] = [6];
    param U4j[] = [1];

    param PERM1[] = [
#     ['i','j'],
     ['j','i'],
    ];
    param PERM2[] = [
     ['i','j'],
#     ['j','i'],
    ];
    param PERM3[] = [
     ['i','j'],
#     ['j','i'],
    ];

    param SCREP[] = [True];
    param IVEC[] = [True];
  }
  
  def search
  {
   arg algorithm = 'Exhaustive';
#   arg algorithm = 'Simplex';
#   arg total_runs = 1;
  }

  def input_params
  {
  let N=250;
  param tmax[] = [500];
  param nx[] = [N];
  param ny[] = [N]; 
  }

  def input_vars
  {
  decl static double ex[nx][ny+1] = random;
  decl static double ey[nx+1][ny] = random;
  decl static double hz[nx][ny] = random;
  }
) @*/

/**-- (Generated by Orio) 
Best performance cost: 
  0.100502 
Tuned for specific problem sizes: 
  nx = 250 
  ny = 250 
  tmax = 500 
Best performance parameters: 
  IVEC = True 
  PERM1 = ['j', 'i'] 
  PERM2 = ['i', 'j'] 
  PERM3 = ['i', 'j'] 
  SCREP = True 
  U1 = 14 
  U2i = 1 
  U2j = 1 
  U3i = 6 
  U3j = 1 
  U4i = 6 
  U4j = 1 
--**/

   

register int i,j,t,it,jt,tt;  

/*@ begin Loop (

for(t=0; t<=tmax-1; t++) {

  transform Composite (  
  scalarreplace = (SCREP, 'double'), 
  regtile = (['i'],[U1]),     
  vector = (IVEC, ['ivdep','vector always']))   
  for (j=0; j<=ny-1; j++)
    ey[0][j] = t;

  transform Composite (  
  permut = [PERM1], 
  scalarreplace = (SCREP, 'double'), 
  regtile = (['i','j'],[U2i,U2j]),     
  vector = (IVEC, ['ivdep','vector always']))   
  for (i=1; i<=nx-1; i++)
    for (j=0; j<=ny-1; j++)
      ey[i][j] = ey[i][j] - 0.5*(hz[i][j]-hz[i-1][j]);

  transform Composite (  
  permut = [PERM2], 
  scalarreplace = (SCREP, 'double'), 
  regtile = (['i','j'],[U3i,U3j]),     
  vector = (IVEC, ['ivdep','vector always']))   
  for (i=0; i<=nx-1; i++)
    for (j=1; j<=ny-1; j++)
      ex[i][j] = ex[i][j] - 0.5*(hz[i][j]-hz[i][j-1]);

  transform Composite (  
  permut = [PERM3], 
  scalarreplace = (SCREP, 'double'), 
  regtile = (['i','j'],[U4i,U4j]),     
  vector = (IVEC, ['ivdep','vector always']))   
  for (i=0; i<=nx-1; i++)
    for (j=0; j<=ny-1; j++)
      hz[i][j]=hz[i][j]-0.7*(ex[i][j+1]-ex[i][j]+ey[i+1][j]-ey[i][j]);
}
) @*/for (t=0; t<=tmax-1; t++ ) {
  {
    register int cbv_1;
    cbv_1=ny-1;
#pragma ivdep
#pragma vector always
    for (j=0; j<=cbv_1; j++ ) {
      ey[0][j]=t;
    }
  }
  {
    for (j=0; j<=ny-1; j++ ) {
      register int cbv_1;
      cbv_1=nx-1;
#pragma ivdep
#pragma vector always
      for (i=1; i<=cbv_1; i++ ) {
        double scv_1;
        scv_1=ey[i][j];
        scv_1=scv_1-0.5*(hz[i][j]-hz[i-1][j]);
        ey[i][j]=scv_1;
      }
    }
  }
  {
    for (it=0; it<=nx-6; it=it+6) {
      register int cbv_1;
      cbv_1=ny-1;
#pragma ivdep
#pragma vector always
      for (j=1; j<=cbv_1; j++ ) {
        double scv_1, scv_2, scv_3, scv_4, scv_5, scv_6;
        scv_1=ex[(it+1)][j];
        scv_2=ex[(it+5)][j];
        scv_3=ex[it][j];
        scv_4=ex[(it+2)][j];
        scv_5=ex[(it+4)][j];
        scv_6=ex[(it+3)][j];
        scv_3=scv_3-0.5*(hz[it][j]-hz[it][j-1]);
        scv_1=scv_1-0.5*(hz[(it+1)][j]-hz[(it+1)][j-1]);
        scv_4=scv_4-0.5*(hz[(it+2)][j]-hz[(it+2)][j-1]);
        scv_6=scv_6-0.5*(hz[(it+3)][j]-hz[(it+3)][j-1]);
        scv_5=scv_5-0.5*(hz[(it+4)][j]-hz[(it+4)][j-1]);
        scv_2=scv_2-0.5*(hz[(it+5)][j]-hz[(it+5)][j-1]);
        ex[(it+1)][j]=scv_1;
        ex[(it+5)][j]=scv_2;
        ex[it][j]=scv_3;
        ex[(it+2)][j]=scv_4;
        ex[(it+4)][j]=scv_5;
        ex[(it+3)][j]=scv_6;
      }
    }
    for (i=it; i<=nx-1; i=i+1) {
      register int cbv_2;
      cbv_2=ny-1;
#pragma ivdep
#pragma vector always
      for (j=1; j<=cbv_2; j++ ) {
        double scv_7;
        scv_7=ex[i][j];
        scv_7=scv_7-0.5*(hz[i][j]-hz[i][j-1]);
        ex[i][j]=scv_7;
      }
    }
  }
  {
    for (it=0; it<=nx-6; it=it+6) {
      register int cbv_1;
      cbv_1=ny-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_1; j++ ) {
        double scv_1, scv_2, scv_3, scv_4, scv_5, scv_6;
        scv_1=hz[(it+4)][j];
        scv_2=hz[(it+3)][j];
        scv_3=hz[(it+5)][j];
        scv_4=hz[(it+2)][j];
        scv_5=hz[(it+1)][j];
        scv_6=hz[it][j];
        scv_6=scv_6-0.7*(ex[it][j+1]-ex[it][j]+ey[it+1][j]-ey[it][j]);
        scv_5=scv_5-0.7*(ex[(it+1)][j+1]-ex[(it+1)][j]+ey[(it+1)+1][j]-ey[(it+1)][j]);
        scv_4=scv_4-0.7*(ex[(it+2)][j+1]-ex[(it+2)][j]+ey[(it+2)+1][j]-ey[(it+2)][j]);
        scv_2=scv_2-0.7*(ex[(it+3)][j+1]-ex[(it+3)][j]+ey[(it+3)+1][j]-ey[(it+3)][j]);
        scv_1=scv_1-0.7*(ex[(it+4)][j+1]-ex[(it+4)][j]+ey[(it+4)+1][j]-ey[(it+4)][j]);
        scv_3=scv_3-0.7*(ex[(it+5)][j+1]-ex[(it+5)][j]+ey[(it+5)+1][j]-ey[(it+5)][j]);
        hz[(it+4)][j]=scv_1;
        hz[(it+3)][j]=scv_2;
        hz[(it+5)][j]=scv_3;
        hz[(it+2)][j]=scv_4;
        hz[(it+1)][j]=scv_5;
        hz[it][j]=scv_6;
      }
    }
    for (i=it; i<=nx-1; i=i+1) {
      register int cbv_2;
      cbv_2=ny-1;
#pragma ivdep
#pragma vector always
      for (j=0; j<=cbv_2; j++ ) {
        double scv_7;
        scv_7=hz[i][j];
        scv_7=scv_7-0.7*(ex[i][j+1]-ex[i][j]+ey[i+1][j]-ey[i][j]);
        hz[i][j]=scv_7;
      }
    }
  }
}
/*@ end @*/

/*@ end @*/



    annot_t_end = rtclock();
    annot_t_total += annot_t_end - annot_t_start;
  }
  
  annot_t_total = annot_t_total / REPS;

#ifndef TEST
  printf("%f\n", annot_t_total);
#else
  {
    int i,j;
    for (i=0; i<nx; i++) {
      for (j=0; j<ny; j++)  {
	if (j%100==0)
          printf("\n");
        printf("%f ",hz[i][j]);
      }
      printf("\n");
    }
  }
#endif


  return ((int) hz[0][0]); 

}
                                    
