#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <math.h>

#define ceild(n,d)  ceil(((double)(n))/((double)(d)))
#define floord(n,d) floor(((double)(n))/((double)(d)))
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y))

double L[N][N];
double U[N][N];
double A[N][N+13];

void init_arrays()
{
  int i, j, k;

  /* have to initialize this matrix properly to prevent                                              
   * division by zero                                                                                 
   */
  for (i=0; i<N; i++) {
    for (j=0; j<N; j++) {
      L[i][j] = 0.0;
      U[i][j] = 0.0;
    }
  }

  for (i=0; i<N; i++) {
    for (j=0; j<=i; j++) {
      L[i][j] = i+j+1;
      U[j][i] = i+j+1;
    }
  }

  for (i=0; i<N; i++) {
    for (j=0; j<N; j++) {
      for (k=0; k<N; k++) {
	A[i][j] += L[i][k]*U[k][j];
      }
    }
  }
}

double rtclock()
{
  struct timezone tzp;
  struct timeval tp;
  int stat;
  gettimeofday (&tp, &tzp);
  return (tp.tv_sec + tp.tv_usec*1.0e-6);
}

int main()
{
  init_arrays();

  double annot_t_start=0, annot_t_end=0, annot_t_total=0;
  int annot_i;

  for (annot_i=0; annot_i<REPS; annot_i++)
    {
      annot_t_start = rtclock();



/*@ begin PerfTuning (         
  def build 
  { 
    arg build_command = 'icc -O3 -openmp -lm'; 
  } 
    
  def performance_counter          
  { 
    arg repetitions = 1; 
  }

  def performance_params 
  {
    param T1_1[] = [16];
    param T1_2[] = [128];
    param T1_3[] = [16];
    param T2_1[] = [4];
    param T2_2[] = [1];
    param T2_3[] = [4];

    constraint c1 = (T1_1*T2_1<=1024 and T1_1*T2_1<=1024 and T1_1*T2_1<=1024);
    constraint c2 = ((T1_1 == T1_3) and (T2_1 == T2_3));

    param U1[] = [3,5,7];
    param U2[] = [1];
    param U3[] = [3,5,7];

    constraint c3 = (U1*U2*U3<=256);

    param PERM[] = [
#      [0,1,2],
#      [0,2,1],
#      [1,0,2],
#      [1,2,0],
      [2,0,1],
#      [2,1,0],
      ];

    param PAR[] = [True];
    param SCREP[] = [True];
    param IVEC[] = [True];
    param RECTILE[] = [False];
  }

  def search 
  { 
    arg algorithm = 'Exhaustive'; 
#    arg algorithm = 'Simplex'; 
#    arg total_runs = 1;
  } 
   
  def input_params 
  {
    param N[] = [2000];
  }

  def input_vars
  {
    arg decl_file = 'decl_code.h';
    arg init_file = 'init_code.c';
  }
) @*/

/**-- (Generated by Orio) 
Best performance cost: 
  0.413585 
Tuned for specific problem sizes: 
  N = 2000 
Best performance parameters: 
  IVEC = True 
  PAR = True 
  PERM = [2, 0, 1] 
  RECTILE = False 
  SCREP = True 
  T1_1 = 16 
  T1_2 = 128 
  T1_3 = 16 
  T2_1 = 4 
  T2_2 = 1 
  T2_3 = 4 
  U1 = 5 
  U2 = 1 
  U3 = 5 
--**/

 

register int i,j,k;
register int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t;
register int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6,
  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12;
register int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6,
  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12;


/*@ begin PolySyn(    
  parallel = PAR;
  tiles = [T1_1,T1_2,T1_3,T2_1,T2_2,T2_3];
  permut = PERM;
  unroll_factors = [U1,U2,U3];
  rect_regtile = RECTILE;
  scalar_replace = SCREP;
  vectorize = IVEC;
    
  profiling_code = 'lu_profiling.c';
  compile_cmd = 'gcc';
  compile_opts = '-lm';
  ) @*/#include <math.h>
#include <assert.h>
#include <omp.h>
#define ceild(n,d)  ceil(((double)(n))/((double)(d)))
#define floord(n,d) floor(((double)(n))/((double)(d)))
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y))





 int c1, c2, c3, c4, c5, c6, c7, c8, c9;
 register int lb, ub, lb1, ub1, lb2, ub2;
/* polysyn start */
if (N >= 2) {
  for (c1=-1;c1<=floord(3*N-5,128);c1++) {
 lb1=max(max(0,ceild(64*c1-N+2,64)),ceild(32*c1-63,96));
 ub1=min(floord(64*c1+63,64),floord(N-1,128));
#pragma omp parallel for shared(c1,lb1,ub1) private(c2,c3,c4,c5,c6,c7,c8,c9)
 for (c2=lb1; c2<=ub1; c2++) {
      for (c3=max(ceild(32*c1-32*c2-1953,2016),ceild(32*c1-32*c2-31,32));c3<=floord(N-1,64);c3++) {
        for (c4=max(max(0,4*c1-4*c2-192*c3-186),4*c1-4*c2);c4<=min(min(min(min(4*c1-4*c2+3,floord(N-2,16)),floord(64*c2+63,8)),floord(480*c3+465,8)),floord(32*c3+31,8));c4++) {
          for (c6=max(max(max(max(ceild(-4*c1+4*c2+4*c3+c4-45,49),ceild(4*c1-4*c2-4*c3-c4-45,47)),ceild(8*c4-105,120)),4*c3),ceild(8*c4-7,8));c6<=min(4*c3+3,floord(N-1,16));c6++) {
            if ((c1 == c2+c3) && (c4 == c6)) {
              for (c7=max(0,16*c6);c7<=min(min(N-2,16*c6+14),128*c2+126);c7++) {
                for (c8=max(128*c2,c7+1);c8<=min(128*c2+127,N-1);c8++) {
                  A[c7][c8]=A[c7][c8]/A[c7][c7];
                  for (c9=c7+1;c9<=min(N-1,16*c6+15);c9++) {
                    A[c9][c8]=A[c9][c8]-A[c9][c7]*A[c7][c8];
                  }
                }
              }
            }
/*@ begin Loop(
transform Composite(
permut = [['c9', 'c7', 'c8']],
  regtile = (['c7', 'c8', 'c9'],[5, 1, 5]),
  scalarreplace = (True, 'double'),
  vector = (True, ['ivdep','vector always']))

            for (c7=max(0,16*c4);c7<=min(min(16*c6-1,16*c4+15),128*c2+126);c7++) {
              for (c8=max(128*c2,c7+1);c8<=min(N-1,128*c2+127);c8++) {
                for (c9=16*c6;c9<=min(N-1,16*c6+15);c9++) {
                  A[c9][c8]=A[c9][c8]-A[c9][c7]*A[c7][c8];
                }
              }
            }

) @*/{
  for (c9t=16*c6; c9t<=min(N-1,16*c6+15)-4; c9t=c9t+5) {
    for (c7t=max(0,16*c4); c7t<=min(min(16*c6-1,16*c4+15),128*c2+126)-4; c7t=c7t+5) {
      for (c7=c7t; c7<=c7t+4; c7=c7+1) {
        register int cbv_1, cbv_2;
        cbv_1=max(128*c2,c7+1);
        cbv_2=min(N-1,128*c2+127);
#pragma ivdep
#pragma vector always
        for (c8=cbv_1; c8<=cbv_2; c8++ ) {
          double scv_1, scv_2, scv_3, scv_4, scv_5, scv_6;
          scv_1=A[(c9t+2)][c8];
          scv_2=A[c9t][c8];
          scv_3=A[(c9t+4)][c8];
          scv_4=A[(c9t+1)][c8];
          scv_5=A[c7][c8];
          scv_6=A[(c9t+3)][c8];
          scv_2=scv_2-A[c9t][c7]*scv_5;
          scv_4=scv_4-A[(c9t+1)][c7]*scv_5;
          scv_1=scv_1-A[(c9t+2)][c7]*scv_5;
          scv_6=scv_6-A[(c9t+3)][c7]*scv_5;
          scv_3=scv_3-A[(c9t+4)][c7]*scv_5;
          A[(c9t+2)][c8]=scv_1;
          A[c9t][c8]=scv_2;
          A[(c9t+4)][c8]=scv_3;
          A[(c9t+1)][c8]=scv_4;
          A[(c9t+3)][c8]=scv_6;
        }
      }
    }
    for (c7=c7t; c7<=min(min(16*c6-1,16*c4+15),128*c2+126); c7=c7+1) {
      register int cbv_3, cbv_4;
      cbv_3=max(128*c2,c7+1);
      cbv_4=min(N-1,128*c2+127);
#pragma ivdep
#pragma vector always
      for (c8=cbv_3; c8<=cbv_4; c8++ ) {
        double scv_7, scv_8, scv_9, scv_10, scv_11, scv_12;
        scv_7=A[(c9t+2)][c8];
        scv_8=A[c9t][c8];
        scv_9=A[(c9t+4)][c8];
        scv_10=A[(c9t+1)][c8];
        scv_11=A[c7][c8];
        scv_12=A[(c9t+3)][c8];
        scv_8=scv_8-A[c9t][c7]*scv_11;
        scv_10=scv_10-A[(c9t+1)][c7]*scv_11;
        scv_7=scv_7-A[(c9t+2)][c7]*scv_11;
        scv_12=scv_12-A[(c9t+3)][c7]*scv_11;
        scv_9=scv_9-A[(c9t+4)][c7]*scv_11;
        A[(c9t+2)][c8]=scv_7;
        A[c9t][c8]=scv_8;
        A[(c9t+4)][c8]=scv_9;
        A[(c9t+1)][c8]=scv_10;
        A[(c9t+3)][c8]=scv_12;
      }
    }
  }
  for (c9=c9t; c9<=min(N-1,16*c6+15); c9=c9+1) {
    for (c7t=max(0,16*c4); c7t<=min(min(16*c6-1,16*c4+15),128*c2+126)-4; c7t=c7t+5) {
      for (c7=c7t; c7<=c7t+4; c7=c7+1) {
        register int cbv_5, cbv_6;
        cbv_5=max(128*c2,c7+1);
        cbv_6=min(N-1,128*c2+127);
#pragma ivdep
#pragma vector always
        for (c8=cbv_5; c8<=cbv_6; c8++ ) {
          double scv_13;
          scv_13=A[c9][c8];
          scv_13=scv_13-A[c9][c7]*A[c7][c8];
          A[c9][c8]=scv_13;
        }
      }
    }
    for (c7=c7t; c7<=min(min(16*c6-1,16*c4+15),128*c2+126); c7=c7+1) {
      register int cbv_7, cbv_8;
      cbv_7=max(128*c2,c7+1);
      cbv_8=min(N-1,128*c2+127);
#pragma ivdep
#pragma vector always
      for (c8=cbv_7; c8<=cbv_8; c8++ ) {
        double scv_14;
        scv_14=A[c9][c8];
        scv_14=scv_14-A[c9][c7]*A[c7][c8];
        A[c9][c8]=scv_14;
      }
    }
  }
}
/*@ end @*/

            if ((c1 == c2+c3) && (c2 >= ceild(16*c4-111,128)) && (-c4 == -c6) && (c4 <= floord(N-17,16))) {
              for (c8=max(16*c4+16,128*c2);c8<=min(N-1,128*c2+127);c8++) {
                A[16*c4+15][c8]=A[16*c4+15][c8]/A[16*c4+15][16*c4+15];
              }
            }
          }
        }
      }
    }
  }
}
/* polysyn end */

/*@ end @*/
/*@ end @*/





      annot_t_end = rtclock();
      annot_t_total += annot_t_end - annot_t_start;
    }

  annot_t_total = annot_t_total / REPS;

#ifndef TEST
  printf("%f\n", annot_t_total);
#else
  {
    int i, j;
    for (i=0; i<N; i++) {
      for (j=0; j<N; j++) {
        if (j%100==0)
          printf("\n");
        printf("%f ",A[i][j]);
      }
      printf("\n");
    }
  }
#endif

  return ((int) A[0][0]);

}
