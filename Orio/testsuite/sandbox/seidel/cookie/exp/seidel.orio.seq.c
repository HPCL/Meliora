#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <math.h>

double A[N][N+13];

void init_arrays()
{
  int i, j;
  for (i=0; i<N; i++) 
    for (j=0; j<N; j++) 
      A[i][j] = i*i+j*j;
}

double rtclock()
{
  struct timezone tzp;
  struct timeval tp;
  int stat;
  gettimeofday (&tp, &tzp);
  return (tp.tv_sec + tp.tv_usec*1.0e-6);
}

int main()
{
  init_arrays();

  double annot_t_start=0, annot_t_end=0, annot_t_total=0;
  int annot_i;

  for (annot_i=0; annot_i<REPS; annot_i++)
  {
    annot_t_start = rtclock();
    

/*@ begin PerfTuning (          
  def build  
  {  
    arg build_command = 'icc -O3 -openmp -lm';  
  }
     
  def performance_counter           
  {  
    arg repetitions = 1;  
  } 
 
  def performance_params  
  { 
# [1,8,16,32,64,128,256]; 
# [1,4,8,16,32];

    param T1_1[] = [16];
    param T1_2[] = [8];
    param T1_3[] = [512];
    param T2_1[] = [1];
    param T2_2[] = [1];
    param T2_3[] = [1];
 
    constraint c1 = (T1_1*T2_1<=1024 and T1_1*T2_1<=1024 and T1_1*T2_1<=1024);

    param U1[] = [3];
    param U2[] = [1];
    param U3[] = [4];

    constraint c2 = (U1*U2*U3<=256);

    param PERM[] = [
     [0,1,2],
#     [0,2,1],
#     [1,0,2],
#     [1,2,0],
#     [2,0,1],
#     [2,1,0],
    ];

    param PAR[] = [False];
    param SCREP[] = [True];
    param IVEC[] = [True];
    param RECTILE[] = [True];
  } 
 
  def search  
  {
    arg algorithm = 'Exhaustive';  
#    arg algorithm = 'Simplex';  
#    arg total_runs = 5; 
  }

  def input_params  
  {
    param T[] = [500];
    param N[] = [4000];
  } 

  def input_vars
  {
    decl static double A[N][N+17] = random;
  }
) @*/

/**-- (Generated by Orio) 
Best performance cost: 
  28.002600 
Tuned for specific problem sizes: 
  N = 4000 
  T = 500 
Best performance parameters: 
  IVEC = True 
  PAR = False 
  PERM = [0, 1, 2] 
  RECTILE = True 
  SCREP = True 
  T1_1 = 16 
  T1_2 = 8 
  T1_3 = 512 
  T2_1 = 1 
  T2_2 = 1 
  T2_3 = 1 
  U1 = 3 
  U2 = 1 
  U3 = 4 
--**/

  

register int i,j,k,t; 
register int c1t, c2t, c3t, c4t, c5t, c6t, c7t, c8t, c9t, c10t, c11t, c12t; 
register int newlb_c1, newlb_c2, newlb_c3, newlb_c4, newlb_c5, newlb_c6, 
  newlb_c7, newlb_c8, newlb_c9, newlb_c10, newlb_c11, newlb_c12; 
register int newub_c1, newub_c2, newub_c3, newub_c4, newub_c5, newub_c6, 
  newub_c7, newub_c8, newub_c9, newub_c10, newub_c11, newub_c12; 

/*@ begin PolySyn( 
  parallel = PAR;
  tiles = [T1_1,T1_2,T1_3,T2_1,T2_2,T2_3];
  permut = PERM;
  unroll_factors = [U1,U2,U3];
  rect_regtile = RECTILE;
  scalar_replace = SCREP;
  vectorize = IVEC;

  profiling_code = 'seidel_profiling.c';
  compile_cmd = 'gcc';
  compile_opts = '-lm';
) @*/#include <math.h>
#include <assert.h>
#define ceild(n,d)  ceil(((double)(n))/((double)(d)))
#define floord(n,d) floor(((double)(n))/((double)(d)))
#define max(x,y)    ((x) > (y)? (x) : (y))
#define min(x,y)    ((x) < (y)? (x) : (y))




 int c1, c2, c3, c4, c5, c6, c7, c8, c9;
/* polysyn start */
if (N >= 3) {
/*@ begin Loop(
transform Composite(
permut = [['c7', 'c8', 'c9']],
  unrolljam = (['c7', 'c8', 'c9'],[3, 1, 4]),
  scalarreplace = (True, 'double'),
  vector = (True, ['ivdep','vector always']))

  for (c1=0;c1<=floord(T-1,16);c1++) {
    for (c2=max(0,ceild(8*c1-3,4));c2<=min(floord(T+N-3,8),floord(16*c1+N+13,8));c2++) {
      for (c3=max(max(max(max(0,ceild(8*c1+4*c2-255,256)),ceild(4*c2-255,256)),ceild(16*c2-N-508,512)),ceild(32*c1-509,512));c3<=min(min(min(min(floord(T+N-3,256),floord(8*c2+T+N+4,512)),floord(16*c2+N+11,512)),floord(16*c1+8*c2+N+20,512)),floord(16*c1+N+13,256));c3++) {
        for (c7=max(max(max(max(0,16*c1),8*c2-N+2),256*c3-N+2),-8*c2+512*c3-N-5);c7<=min(min(min(min(T-1,16*c1+15),8*c2+6),floord(512*c3+509,2)),-8*c2+512*c3+510);c7++) {
          for (c8=max(max(8*c2,c7+1),512*c3-c7-N+2);c8<=min(min(8*c2+7,c7+N-2),512*c3-c7+510);c8++) {
            for (c9=max(512*c3,c7+c8+1);c9<=min(512*c3+511,c7+c8+N-2);c9++) {
              A[-c7+c8][-c7-c8+c9]=(A[1+-c7+c8][1+-c7-c8+c9]+A[1+-c7+c8][-c7-c8+c9]+A[1+-c7+c8][-c7-c8+c9-1]+A[-c7+c8][1+-c7-c8+c9]+A[-c7+c8][-c7-c8+c9]+A[-c7+c8][-c7-c8+c9-1]+A[-c7+c8-1][1+-c7-c8+c9]+A[-c7+c8-1][-c7-c8+c9]+A[-c7+c8-1][-c7-c8+c9-1])/9;
            }
          }
        }
      }
    }
  }

) @*/{
  for (c1=0; c1<=floord(T-1,16); c1++ ) {
    for (c2=max(0,ceild(8*c1-3,4)); c2<=min(floord(T+N-3,8),floord(16*c1+N+13,8)); c2++ ) {
      for (c3=max(max(max(max(0,ceild(8*c1+4*c2-255,256)),ceild(4*c2-255,256)),ceild(16*c2-N-508,512)),ceild(32*c1-509,512)); c3<=min(min(min(min(floord(T+N-3,256),floord(8*c2+T+N+4,512)),floord(16*c2+N+11,512)),floord(16*c1+8*c2+N+20,512)),floord(16*c1+N+13,256)); c3++ ) {
        {
          for (c7=max(max(max(max(0,16*c1),8*c2-N+2),256*c3-N+2),-8*c2+512*c3-N-5); c7<=min(min(min(min(T-1,16*c1+15),8*c2+6),floord(512*c3+509,2)),-8*c2+512*c3+510)-2; c7=c7+3) {
            for (c8=max(max(8*c2,c7+1),512*c3-c7-N+2); c8<=min(min(8*c2+7,c7+N-2),512*c3-c7+510); c8++ ) {
              {
                register int cbv_1, cbv_2;
                cbv_1=max(512*c3,c7+c8+1);
                cbv_2=min(512*c3+511,c7+c8+N-2)-3;
#pragma ivdep
#pragma vector always
                for (c9=cbv_1; c9<=cbv_2; c9=c9+4) {
                  double scv_1, scv_2, scv_3, scv_4, scv_5, scv_6, scv_7, scv_8;
                  double scv_9, scv_10, scv_11, scv_12;
                  scv_1=A[-c7+c8+1][-c7+c9-c8+2];
                  scv_2=A[-c7+c8][-c7+c9-c8+3];
                  scv_3=A[-c7+c8+1][-c7+c9-c8+3];
                  scv_4=A[-c7+c8-1][-c7+c9-c8+3];
                  scv_5=A[-c7+c8][-c7+c9-c8+1];
                  scv_6=A[-c7+c8][-c7+c9-c8];
                  scv_7=A[-c7+c8-1][-c7+c9-c8+2];
                  scv_8=A[-c7+c8+1][-c7+c9-c8+1];
                  scv_9=A[-c7+c8+1][-c7+c9-c8];
                  scv_10=A[-c7+c8][-c7+c9-c8+2];
                  scv_11=A[-c7+c8-1][-c7+c9-c8];
                  scv_12=A[-c7+c8-1][-c7+c9-c8+1];
                  scv_6=0.111111111111*(scv_8+scv_9+A[-c7+c8+1][-c7+c9-c8-1]+scv_5+scv_6+A[-c7+c8][-c7+c9-c8-1]+scv_12+scv_11+A[-c7+c8-1][-c7+c9-c8-1]);
                  scv_5=0.111111111111*(scv_1+scv_8+scv_9+scv_10+scv_5+scv_6+scv_7+scv_12+scv_11);
                  scv_10=0.111111111111*(scv_3+scv_1+scv_8+scv_2+scv_10+scv_5+scv_4+scv_7+scv_12);
                  scv_2=0.111111111111*(A[-c7+c8+1][-c7+c9-c8+4]+scv_3+scv_1+A[-c7+c8][-c7+c9-c8+4]+scv_2+scv_10+A[-c7+c8-1][-c7+c9-c8+4]+scv_4+scv_7);
                  A[-c7+c8][-c7+c9-c8+3]=scv_2;
                  A[-c7+c8][-c7+c9-c8+1]=scv_5;
                  A[-c7+c8][-c7+c9-c8]=scv_6;
                  A[-c7+c8][-c7+c9-c8+2]=scv_10;
                }
                register int cbv_3;
                cbv_3=min(512*c3+511,c7+c8+N-2);
#pragma ivdep
#pragma vector always
                for (; c9<=cbv_3; c9=c9+1) {
                  double scv_13;
                  scv_13=A[-c7+c8][-c7+c9-c8];
                  scv_13=0.111111111111*(A[-c7+c8+1][-c7+c9-c8+1]+A[-c7+c8+1][-c7+c9-c8]+A[-c7+c8+1][-c7+c9-c8-1]+A[-c7+c8][-c7+c9-c8+1]+scv_13+A[-c7+c8][-c7+c9-c8-1]+A[-c7+c8-1][-c7+c9-c8+1]+A[-c7+c8-1][-c7+c9-c8]+A[-c7+c8-1][-c7+c9-c8-1]);
                  A[-c7+c8][-c7+c9-c8]=scv_13;
                }
              }
            }
            for (c8=max(max(8*c2,c7+2),512*c3-c7-N+1); c8<=min(min(8*c2+7,c7+N-1),512*c3-c7+509); c8++ ) {
              {
                register int cbv_4, cbv_5;
                cbv_4=max(512*c3,c7+c8+2);
                cbv_5=min(512*c3+511,c7+c8+N-1)-3;
#pragma ivdep
#pragma vector always
                for (c9=cbv_4; c9<=cbv_5; c9=c9+4) {
                  double scv_14, scv_15, scv_16, scv_17, scv_18, scv_19, scv_20, scv_21;
                  double scv_22, scv_23, scv_24, scv_25;
                  scv_14=A[-(c7+1)+c8][-(c7+1)+c9-c8+1];
                  scv_15=A[-(c7+1)+c8+1][-(c7+1)+c9-c8];
                  scv_16=A[-(c7+1)+c8+1][-(c7+1)+c9-c8+3];
                  scv_17=A[-(c7+1)+c8-1][-(c7+1)+c9-c8+2];
                  scv_18=A[-(c7+1)+c8-1][-(c7+1)+c9-c8+3];
                  scv_19=A[-(c7+1)+c8-1][-(c7+1)+c9-c8+1];
                  scv_20=A[-(c7+1)+c8][-(c7+1)+c9-c8];
                  scv_21=A[-(c7+1)+c8][-(c7+1)+c9-c8+3];
                  scv_22=A[-(c7+1)+c8-1][-(c7+1)+c9-c8];
                  scv_23=A[-(c7+1)+c8][-(c7+1)+c9-c8+2];
                  scv_24=A[-(c7+1)+c8+1][-(c7+1)+c9-c8+1];
                  scv_25=A[-(c7+1)+c8+1][-(c7+1)+c9-c8+2];
                  scv_20=0.111111111111*(scv_24+scv_15+A[-(c7+1)+c8+1][-(c7+1)+c9-c8-1]+scv_14+scv_20+A[-(c7+1)+c8][-(c7+1)+c9-c8-1]+scv_19+scv_22+A[-(c7+1)+c8-1][-(c7+1)+c9-c8-1]);
                  scv_14=0.111111111111*(scv_25+scv_24+scv_15+scv_23+scv_14+scv_20+scv_17+scv_19+scv_22);
                  scv_23=0.111111111111*(scv_16+scv_25+scv_24+scv_21+scv_23+scv_14+scv_18+scv_17+scv_19);
                  scv_21=0.111111111111*(A[-(c7+1)+c8+1][-(c7+1)+c9-c8+4]+scv_16+scv_25+A[-(c7+1)+c8][-(c7+1)+c9-c8+4]+scv_21+scv_23+A[-(c7+1)+c8-1][-(c7+1)+c9-c8+4]+scv_18+scv_17);
                  A[-(c7+1)+c8][-(c7+1)+c9-c8+1]=scv_14;
                  A[-(c7+1)+c8][-(c7+1)+c9-c8]=scv_20;
                  A[-(c7+1)+c8][-(c7+1)+c9-c8+3]=scv_21;
                  A[-(c7+1)+c8][-(c7+1)+c9-c8+2]=scv_23;
                }
                register int cbv_6;
                cbv_6=min(512*c3+511,c7+c8+N-1);
#pragma ivdep
#pragma vector always
                for (; c9<=cbv_6; c9=c9+1) {
                  double scv_26;
                  scv_26=A[-(c7+1)+c8][-(c7+1)+c9-c8];
                  scv_26=0.111111111111*(A[-(c7+1)+c8+1][-(c7+1)+c9-c8+1]+A[-(c7+1)+c8+1][-(c7+1)+c9-c8]+A[-(c7+1)+c8+1][-(c7+1)+c9-c8-1]+A[-(c7+1)+c8][-(c7+1)+c9-c8+1]+scv_26+A[-(c7+1)+c8][-(c7+1)+c9-c8-1]+A[-(c7+1)+c8-1][-(c7+1)+c9-c8+1]+A[-(c7+1)+c8-1][-(c7+1)+c9-c8]+A[-(c7+1)+c8-1][-(c7+1)+c9-c8-1]);
                  A[-(c7+1)+c8][-(c7+1)+c9-c8]=scv_26;
                }
              }
            }
            for (c8=max(max(8*c2,c7+3),512*c3-c7-N); c8<=min(min(8*c2+7,c7+N),512*c3-c7+508); c8++ ) {
              {
                register int cbv_7, cbv_8;
                cbv_7=max(512*c3,c7+c8+3);
                cbv_8=min(512*c3+511,c7+c8+N)-3;
#pragma ivdep
#pragma vector always
                for (c9=cbv_7; c9<=cbv_8; c9=c9+4) {
                  double scv_27, scv_28, scv_29, scv_30, scv_31, scv_32, scv_33, scv_34;
                  double scv_35, scv_36, scv_37, scv_38;
                  scv_27=A[-(c7+2)+c8][-(c7+2)+c9-c8];
                  scv_28=A[-(c7+2)+c8][-(c7+2)+c9-c8+3];
                  scv_29=A[-(c7+2)+c8+1][-(c7+2)+c9-c8];
                  scv_30=A[-(c7+2)+c8][-(c7+2)+c9-c8+2];
                  scv_31=A[-(c7+2)+c8+1][-(c7+2)+c9-c8+3];
                  scv_32=A[-(c7+2)+c8+1][-(c7+2)+c9-c8+1];
                  scv_33=A[-(c7+2)+c8][-(c7+2)+c9-c8+1];
                  scv_34=A[-(c7+2)+c8-1][-(c7+2)+c9-c8+3];
                  scv_35=A[-(c7+2)+c8-1][-(c7+2)+c9-c8];
                  scv_36=A[-(c7+2)+c8-1][-(c7+2)+c9-c8+2];
                  scv_37=A[-(c7+2)+c8+1][-(c7+2)+c9-c8+2];
                  scv_38=A[-(c7+2)+c8-1][-(c7+2)+c9-c8+1];
                  scv_27=0.111111111111*(scv_32+scv_29+A[-(c7+2)+c8+1][-(c7+2)+c9-c8-1]+scv_33+scv_27+A[-(c7+2)+c8][-(c7+2)+c9-c8-1]+scv_38+scv_35+A[-(c7+2)+c8-1][-(c7+2)+c9-c8-1]);
                  scv_33=0.111111111111*(scv_37+scv_32+scv_29+scv_30+scv_33+scv_27+scv_36+scv_38+scv_35);
                  scv_30=0.111111111111*(scv_31+scv_37+scv_32+scv_28+scv_30+scv_33+scv_34+scv_36+scv_38);
                  scv_28=0.111111111111*(A[-(c7+2)+c8+1][-(c7+2)+c9-c8+4]+scv_31+scv_37+A[-(c7+2)+c8][-(c7+2)+c9-c8+4]+scv_28+scv_30+A[-(c7+2)+c8-1][-(c7+2)+c9-c8+4]+scv_34+scv_36);
                  A[-(c7+2)+c8][-(c7+2)+c9-c8]=scv_27;
                  A[-(c7+2)+c8][-(c7+2)+c9-c8+3]=scv_28;
                  A[-(c7+2)+c8][-(c7+2)+c9-c8+2]=scv_30;
                  A[-(c7+2)+c8][-(c7+2)+c9-c8+1]=scv_33;
                }
                register int cbv_9;
                cbv_9=min(512*c3+511,c7+c8+N);
#pragma ivdep
#pragma vector always
                for (; c9<=cbv_9; c9=c9+1) {
                  double scv_39;
                  scv_39=A[-(c7+2)+c8][-(c7+2)+c9-c8];
                  scv_39=0.111111111111*(A[-(c7+2)+c8+1][-(c7+2)+c9-c8+1]+A[-(c7+2)+c8+1][-(c7+2)+c9-c8]+A[-(c7+2)+c8+1][-(c7+2)+c9-c8-1]+A[-(c7+2)+c8][-(c7+2)+c9-c8+1]+scv_39+A[-(c7+2)+c8][-(c7+2)+c9-c8-1]+A[-(c7+2)+c8-1][-(c7+2)+c9-c8+1]+A[-(c7+2)+c8-1][-(c7+2)+c9-c8]+A[-(c7+2)+c8-1][-(c7+2)+c9-c8-1]);
                  A[-(c7+2)+c8][-(c7+2)+c9-c8]=scv_39;
                }
              }
            }
          }
          for (; c7<=min(min(min(min(T-1,16*c1+15),8*c2+6),floord(512*c3+509,2)),-8*c2+512*c3+510); c7=c7+1) {
            for (c8=max(max(8*c2,c7+1),512*c3-c7-N+2); c8<=min(min(8*c2+7,c7+N-2),512*c3-c7+510); c8++ ) {
              {
                register int cbv_10, cbv_11;
                cbv_10=max(512*c3,c7+c8+1);
                cbv_11=min(512*c3+511,c7+c8+N-2)-3;
#pragma ivdep
#pragma vector always
                for (c9=cbv_10; c9<=cbv_11; c9=c9+4) {
                  double scv_40, scv_41, scv_42, scv_43, scv_44, scv_45, scv_46, scv_47;
                  double scv_48, scv_49, scv_50, scv_51;
                  scv_40=A[-c7+c8+1][-c7+c9-c8+2];
                  scv_41=A[-c7+c8][-c7+c9-c8+3];
                  scv_42=A[-c7+c8+1][-c7+c9-c8+3];
                  scv_43=A[-c7+c8-1][-c7+c9-c8+3];
                  scv_44=A[-c7+c8][-c7+c9-c8+1];
                  scv_45=A[-c7+c8][-c7+c9-c8];
                  scv_46=A[-c7+c8-1][-c7+c9-c8+2];
                  scv_47=A[-c7+c8+1][-c7+c9-c8+1];
                  scv_48=A[-c7+c8+1][-c7+c9-c8];
                  scv_49=A[-c7+c8][-c7+c9-c8+2];
                  scv_50=A[-c7+c8-1][-c7+c9-c8];
                  scv_51=A[-c7+c8-1][-c7+c9-c8+1];
                  scv_45=0.111111111111*(scv_47+scv_48+A[-c7+c8+1][-c7+c9-c8-1]+scv_44+scv_45+A[-c7+c8][-c7+c9-c8-1]+scv_51+scv_50+A[-c7+c8-1][-c7+c9-c8-1]);
                  scv_44=0.111111111111*(scv_40+scv_47+scv_48+scv_49+scv_44+scv_45+scv_46+scv_51+scv_50);
                  scv_49=0.111111111111*(scv_42+scv_40+scv_47+scv_41+scv_49+scv_44+scv_43+scv_46+scv_51);
                  scv_41=0.111111111111*(A[-c7+c8+1][-c7+c9-c8+4]+scv_42+scv_40+A[-c7+c8][-c7+c9-c8+4]+scv_41+scv_49+A[-c7+c8-1][-c7+c9-c8+4]+scv_43+scv_46);
                  A[-c7+c8][-c7+c9-c8+3]=scv_41;
                  A[-c7+c8][-c7+c9-c8+1]=scv_44;
                  A[-c7+c8][-c7+c9-c8]=scv_45;
                  A[-c7+c8][-c7+c9-c8+2]=scv_49;
                }
                register int cbv_12;
                cbv_12=min(512*c3+511,c7+c8+N-2);
#pragma ivdep
#pragma vector always
                for (; c9<=cbv_12; c9=c9+1) {
                  double scv_52;
                  scv_52=A[-c7+c8][-c7-c8+c9];
                  scv_52=(A[1+-c7+c8][1+-c7-c8+c9]+A[1+-c7+c8][-c7-c8+c9]+A[1+-c7+c8][-c7-c8+c9-1]+A[-c7+c8][1+-c7-c8+c9]+scv_52+A[-c7+c8][-c7-c8+c9-1]+A[-c7+c8-1][1+-c7-c8+c9]+A[-c7+c8-1][-c7-c8+c9]+A[-c7+c8-1][-c7-c8+c9-1])/9;
                  A[-c7+c8][-c7-c8+c9]=scv_52;
                }
              }
            }
          }
        }
      }
    }
  }
}
/*@ end @*/

}
/* polysyn end */

/*@ end @*/ 
/*@ end @*/ 



    annot_t_end = rtclock();
    annot_t_total += annot_t_end - annot_t_start;
  }
  
  annot_t_total = annot_t_total / REPS;

#ifndef TEST
  printf("%f\n", annot_t_total);
#else
  {
    int i, j;
    for (i=0; i<N; i++) {
      for (j=0; j<N; j++) {
	if (j%100==0)
	  printf("\n");
	printf("%f ",A[i][j]);
      }
      printf("\n");
    }
  }
#endif
  
  return ((int) A[0][0]); 

}
                                    
