/*@ begin PerfTuning (  
 def build { 
   arg build_command = 'icc -O3 -openmp -lm -I/disks/fast/papi/include -L/disks/fast/papi/lib -lpapi';
 }

 def performance_counter {
   arg repetitions = 100;
 }

 def performance_params {
   param UNROLL_FAC_OUT[] = [4];
   param UNROLL_FAC_IN[] = [1,2,3,4,5,6,7,8];
   param N_THREADS[] = [1,4];
   param SIMD_TYPE[] = ['none','sse'];
   param BLK_TYPE[] = ['inode'];

   constraint simd_unroll_factor = (SIMD_TYPE=='none' or UNROLL_FAC_IN%2==0);
 }

 def input_params {
   param G_NROWS[] = [32000,34000];
   param G_NCOLS[] = [32000,34000];
   param B_NROWS[] = [4];
   param B_NCOLS_MIN[] = [12];
   param B_NCOLS_MAX[] = [20];
   param B_NCOLS_STRIDE[] = [4];

   constraint square_x_y = (G_NROWS==G_NCOLS);
 }
 
 def input_vars { 
   arg decl_file = 'decl_code.h';
   arg init_file = 'init_code.c'; 
 } 
 
 def performance_test_code { 
   arg skeleton_code_file = 'skeleton_code.c';  
 } 

 def search
 {
   arg algorithm = 'Exhaustive';
 }  
 ) @*/

/**-- (Generated by Orio) 
Best performance cost: 
  453325.000000 
Tuned for specific problem sizes: 
  B_NCOLS_MAX = 20 
  B_NCOLS_MIN = 12 
  B_NCOLS_STRIDE = 4 
  B_NROWS = 4 
  G_NCOLS = 34000 
  G_NROWS = 34000 
Best performance parameters: 
  BLK_TYPE = inode 
  N_THREADS = 4 
  SIMD_TYPE = none 
  UNROLL_FAC_IN = 6 
  UNROLL_FAC_OUT = 4 
--**/

 

/*@ begin SpMV (
  # SpMV computation: y = y + aa * x;
  out_vector = y;
  in_vector = x;
  in_matrix = aa;
  row_inds = ai;
  col_inds = aj;
  data_type = double;
  init_val = 0;
  total_rows = total_rows;       
  total_inodes = total_inodes;   
  inode_sizes = inode_sizes;     
  inode_rows = inode_rows;       
  
  # transformation parameters
  out_unroll_factor = UNROLL_FAC_OUT;
  in_unroll_factor = UNROLL_FAC_IN;
  num_threads = N_THREADS;
  simd = SIMD_TYPE;              # 'none' (default), 'gcc', 'sse', 'xlc'
  block_structure = BLK_TYPE;    # 'none' (default), 'inode', 'bcsr' (still unsupported)
  ) @*/
{

  register int n;
  omp_set_num_threads(4);
  #pragma omp parallel for shared(y,x,aa,ai,aj,total_inodes,inode_rows) private(n)
  for (n=0; n<=total_inodes-1; n+=1) {
    int start_row=inode_rows[n];
    register int rlength=inode_rows[n+1]-start_row;
    int first_col=ai[start_row];
    register int clength=ai[start_row+1]-first_col;
    double *yc=&y[start_row];
    int *ajc=&aj[first_col];
    double *aac=&aa[first_col];
    register int i=0;
    while (i<=rlength-4) {
      double *aa1c=aac+clength,*aa2c=aa1c+clength,*aa3c=aa2c+clength;
      double y0c=0,y1c=0,y2c=0,y3c=0;
      register int j=0;
      while (j<=clength-6) {
        double x0=x[ajc[0]],x1=x[ajc[1]],x2=x[ajc[2]],x3=x[ajc[3]],x4=x[ajc[4]],x5=x[ajc[5]];
        y0c += aac[0]*x0 + aac[1]*x1 + aac[2]*x2 + aac[3]*x3 + aac[4]*x4 + aac[5]*x5;
        y1c += aa1c[0]*x0 + aa1c[1]*x1 + aa1c[2]*x2 + aa1c[3]*x3 + aa1c[4]*x4 + aa1c[5]*x5;
        y2c += aa2c[0]*x0 + aa2c[1]*x1 + aa2c[2]*x2 + aa2c[3]*x3 + aa2c[4]*x4 + aa2c[5]*x5;
        y3c += aa3c[0]*x0 + aa3c[1]*x1 + aa3c[2]*x2 + aa3c[3]*x3 + aa3c[4]*x4 + aa3c[5]*x5;
        aac+=6; aa1c+=6; aa2c+=6; aa3c+=6;
        ajc+=6;
        j+=6;
      }
      while (j<=clength-1) {
        double x0=x[ajc[0]];
        y0c += aac[0]*x0;
        y1c += aa1c[0]*x0;
        y2c += aa2c[0]*x0;
        y3c += aa3c[0]*x0;
        aac+=1; aa1c+=1; aa2c+=1; aa3c+=1;
        ajc+=1;
        j+=1;
      }
      yc[0]=y0c; yc[1]=y1c; yc[2]=y2c; yc[3]=y3c;
      yc+=4;
      aac=aa3c;
      ajc+=3*clength;
      i+=4;
    }
    while (i<=rlength-1) {
      double y0c=0;
      register int j=0;
      while (j<=clength-6) {
        y0c += aac[0]*x[ajc[0]] + aac[1]*x[ajc[1]] + aac[2]*x[ajc[2]] + aac[3]*x[ajc[3]] + aac[4]*x[ajc[4]] + aac[5]*x[ajc[5]];
        aac+=6;
        ajc+=6;
        j+=6;
      }
      while (j<=clength-1) {
        y0c += aac[0]*x[ajc[0]];
        aac+=1;
        ajc+=1;
        j+=1;
      }
      yc[0]=y0c;
      yc+=1;
      i+=1;
    }
  }
  
}
/*@ end @*/

/*@ end @*/

